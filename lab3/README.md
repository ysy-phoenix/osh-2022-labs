## 双人聊天室

消息缓冲区长度为 1024，每接收一次消息(其长度为 recv 的返回值而不一定是 1024)，先根据换行进行分割，遇到换行则发送一次消息。

对每次残留的消息（指结尾不是换行）也进行发送（但是不换行）。

每次发送时只有初始或者上一次遇到换行才会输出 `message:`，也就是不会显示多余的 `message:`

例如一次发送了长为 4096 的消息，只有最后是换行，前三次每次接收 1024（假定 1024 长度能成功接收），然后发送（不会有换行），第四次再接收 1024 的消息，结尾是换行，一并发送，并且只有第一次会输出 `message:`。

## 基于多线程的多人聊天室

根据要求消息的长度不超过 1 MiB，因此每条消息的缓冲区设置为 1 MiB，每次 recv 后先把消息存到缓冲区，遇到换行再发送，与上一步双人聊天室的处理略有不同。

全局维护了一个消息队列，同时每个客户端对应有两个线程，一个用来 recv（该客户端接收消息），一个用来 send（将消息发送给该客户端）。

每次客户端 recv 后，先把消息发送给消息队列(服务端)，也即入队。然后对应的 send 线程在队列非空，且发消息的客户端与自身不同时才进行 send。

仅针对队列的维护进行加锁。

## 基于 IO 复用

实现了 `SELECT`（3.c） 和 `EPOLL`(4.c)。

send 和 recv 的处理与之前类似，针对事件的响应分为新用户加入，接受到新消息和用户退出三种情况进行相应处理。